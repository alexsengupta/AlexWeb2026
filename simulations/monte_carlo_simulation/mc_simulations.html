<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Monte Carlo Simulations</title>
  <style>
    :root {
      --bg: #3e3a36;
      --pane: #5a534d;
      --text: #d9cbb6;
      --accent: #a67c00;
      --inactive: #7a6f63;
      --trend: #000;
      --randTrend: #ffeb3b;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 20px;
    }

    h1 {
      margin: 0 0 10px 0;
      text-align: center;
    }

    #topChart {
      position: relative;
      width: 100%;
      height: 480px;
      background: var(--pane);
      border-radius: 8px;
      padding: 10px;
    }

    #topChart .innerLegend,
    #topChart .innerCount {
      position: absolute;
      font-size: 14px;
      color: #d9cbb6;
      background: rgba(0, 0, 0, .55);
      padding: 6px 8px;
      border-radius: 4px;
      pointer-events: none
    }

    #topChart .innerLegend {
      left: 50px;
      bottom: 50px;
      line-height: 20px;
      display: flex;
      flex-direction: column;
      gap: 2px
    }

    #topChart .innerCount {
      right: 50px;
      bottom: 50px
    }

    #bottomRow {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 20px;
    }

    #hist {
      flex: 2 1 420px;
      height: 280px;
      background: var(--pane);
      border-radius: 8px;
      padding: 10px;
      box-sizing: border-box;
    }

    #steps {
      flex: 1 1 250px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .stepBox {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
      color: var(--text);
    }

    .step {
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 5px;
      padding: 8px 12px;
      font-weight: bold;
      cursor: pointer;
      transition: opacity .3s;
    }

    .step:disabled {
      opacity: .4;
      cursor: default;
    }

    #significance {
      margin-top: 15px;
      display: none;
      background: var(--pane);
      padding: 12px;
      border-radius: 8px;
      line-height: 1.4;
    }

    .help-icon {
      cursor: pointer;
      font-weight: bold;
      color: #d9cbb6;
      margin-left: 5px;
      border: 1px solid #d9cbb6;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: inline-block;
      text-align: center;
      line-height: 20px;
    }

    .help-modal {
      display: none;
      position: fixed;
      z-index: 1;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.4);
    }

    .help-modal-content {
      background-color: #5a534d;
      margin: 15% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 600px;
      border-radius: 8px;
      box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
    }

    .close-help {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
    }

    .close-help:hover,
    .close-help:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div style="position: absolute; top: 20px; left: 20px; display: flex; gap: 10px; z-index: 1000;">
    <a href="../../app_playground.html"
      style="text-decoration: none; background: rgba(255,255,255,0.1); color: #d9cbb6; padding: 8px 15px; border-radius: 99px; font-size: 14px; display: flex; align-items: center; gap: 8px; transition: background 0.2s; border: 1px solid rgba(255,255,255,0.2);">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round">
        <path d="M19 12H5M12 19l-7-7 7-7" />
      </svg>
      Playground
    </a>
    <a href="../../index.html"
      style="text-decoration: none; background: rgba(255,255,255,0.1); color: #d9cbb6; padding: 8px 15px; border-radius: 99px; font-size: 14px; display: flex; align-items: center; gap: 8px; transition: background 0.2s; border: 1px solid rgba(255,255,255,0.2);">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round">
        <path
          d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
      </svg>
      Home
    </a>
  </div>
  <h1>Significance Test: Simple (IID) Bootstrap</h1>

  <div id="topChart">
    <canvas id="timeCanvas"></canvas>
    <div class="innerLegend">
      <svg width="160" height="90">
        <line x1="0" y1="8" x2="20" y2="8" stroke="#a67c00" stroke-width="3" />
        <text x="24" y="12" fill="#d9cbb6">Original</text>

        <line x1="0" y1="26" x2="20" y2="26" stroke="#000" stroke-width="2" stroke-dasharray="4 2" />
        <text x="24" y="30" fill="#d9cbb6">Original trend</text>

        <line x1="0" y1="44" x2="20" y2="44" stroke="#fff" stroke-width="2" stroke-dasharray="2 2" />
        <text x="24" y="48" fill="#d9cbb6">Random series</text>

        <line x1="0" y1="62" x2="20" y2="62" stroke="#ffeb3b" stroke-width="2" />
        <text x="24" y="66" fill="#d9cbb6">Random trend</text>
      </svg>
    </div>
    <div class="innerCount" id="iterDisplay">Iterations: 0</div>
  </div>

  <div id="bottomRow">
    <div id="hist"><canvas id="histCanvas"></canvas></div>
    <div id="steps">
      <div class="stepBox">Step 1: Consider all data points as independent samples <span class="help-icon"
          onclick="showHelp('s1-simple')">?</span> <button id="s1" class="step">View data points</button></div>
      <div class="stepBox">Step 2: Remove trend <span class="help-icon" onclick="showHelp('s2-simple')">?</span> <button
          id="s2" class="step" disabled>Isolate the 'Noise'</button></div>
      <div class="stepBox">Step 3: Resample points <span class="help-icon" onclick="showHelp('s3-simple')">?</span>
        <button id="s3" class="step" disabled>Shuffle the Noise</button>
      </div>
      <div class="stepBox" id="s4Box">Step 4: Build histogram <button id="s4" class="step" disabled>Repeat
          1000×</button></div>
      <div class="stepBox">Step 5: Compare <button id="s5" class="step" disabled>Compare actual</button></div>
    </div>
  </div>
  <div id="significance"></div>

  <div id="helpModal" class="help-modal">
    <div class="help-modal-content">
      <span class="close-help" onclick="closeHelp()">&times;</span>
      <h2 id="helpTitle"></h2>
      <p id="helpBody"></p>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.7.0/dist/simple-statistics.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
  <script>
    /* ---------- URL params ---------- */
    const P = new URLSearchParams(location.search);
    const L = +P.get('length') || 100, σ = +P.get('stdDev') || 1, tr = +P.get('trend') || 0, ar = +P.get('autoCorr') || 0, seed = +P.get('randomSeed') || Math.random();
    const mul = s => { return () => (s = Math.imul(s ^ s >>> 15, s | 1), s += Math.imul(s ^ s >>> 7, s | 61), ((s ^ s >>> 14) >>> 0) / 4294967296) };
    const randn = r => { let u = 0, v = 0; while (!u) u = r(); while (!v) v = r(); return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v) };
    const rng = mul(Math.floor(seed * 4294967296));

    function gen(len, std, trend, ac, rng) { const y = [], tLine = []; let prev = 0; for (let i = 0; i < len; i++) { tLine.push(trend * i); prev = ac * prev + (1 - Math.abs(ac)) * randn(rng) * std; y.push(trend * i + prev) } return { y, tLine } }
    const { y: original, tLine: origTrend } = gen(L, σ, tr, ar, rng);
    const labels = [...Array(L).keys()].map(i => i + 1);
    const yMax = Math.max(...original, ...origTrend.map(v => Math.abs(v))) * 1.1;

    /* ---------- top canvas ---------- */
    const tCtx = document.getElementById('timeCanvas').getContext('2d');
    const hCtx = document.getElementById('histCanvas').getContext('2d');
    let tChart, hChart, latestSlope = null;
    tChart = new Chart(tCtx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          { label: 'Original', data: original, borderColor: '#a67c00', backgroundColor: '#a67c00', fill: false, pointRadius: 0, borderWidth: 3, tension: .2 },
          { label: 'Original trend', data: origTrend, borderColor: '#000', borderDash: [5, 5], fill: false, pointRadius: 0, borderWidth: 2 }
        ]
      },
      options: { responsive: true, maintainAspectRatio: false, animation: false, scales: { x: { ticks: { color: '#d9cbb6' }, grid: { color: '#7a6f63' } }, y: { min: -yMax, max: yMax, ticks: { color: '#d9cbb6' }, grid: { color: '#7a6f63' } } }, plugins: { legend: { display: false } } }
    });

    /* histogram – 15 equal-width bins ---------- */
    const binCount = 15; let binWidth, binMin, binMax;
    function updateBins() {
      if (trends.length) { const pad = Math.max((Math.max(...trends) - Math.min(...trends)) * 0.1, 1e-6); binMin = Math.min(...trends) - pad; binMax = Math.max(...trends) + pad; }
      else { binMin = -Math.max(Math.abs(tr), σ * 2); binMax = Math.max(Math.abs(tr), σ * 2); }
      binWidth = (binMax - binMin) / binCount;
    }
    hChart = new Chart(hCtx, {
      type: 'bar',
      data: { datasets: [{ label: 'Frequency', data: [], backgroundColor: '#a67c00', barPercentage: 1, categoryPercentage: 1 }] },
      options: { responsive: true, maintainAspectRatio: false, animation: false, plugins: { legend: { display: false }, annotation: { annotations: {} } }, scales: { x: { type: 'linear', title: { display: true, text: 'Trend', color: '#d9cbb6' }, ticks: { color: '#d9cbb6' }, grid: { color: '#7a6f63' } }, y: { title: { display: true, text: 'Count', color: '#d9cbb6' }, ticks: { color: '#d9cbb6', precision: 0 }, grid: { color: '#7a6f63' } } } }
    });

    /* ---------- state ---------- */
    let detrended = [], colors = [], trends = [], iters = 0, manualCount = 0;
    const colorArray = n => [...Array(n)].map((_, i) => `hsl(${(i * 137.508) % 360},70%,60%)`);
    const addDs = (l, d, opt = {}) => { if (!tChart.data.datasets.find(ds => ds.label === l)) { tChart.data.datasets.push({ label: l, data: d, ...opt }); tChart.update('none') } };
    const remDs = l => { const i = tChart.data.datasets.findIndex(ds => ds.label === l); if (i > -1) { tChart.data.datasets.splice(i, 1); tChart.update('none') } };
    const disable = b => { b.disabled = true; b.style.opacity = '0.4' };
    const enable = b => { b.disabled = false; b.style.opacity = '1' };
    const iterDisplay = document.getElementById('iterDisplay');

    /* ---------- buttons ---------- */
    const s1 = document.getElementById('s1'), s2 = document.getElementById('s2'), s3 = document.getElementById('s3'), s4 = document.getElementById('s4'), s4Box = document.getElementById('s4Box'), s5 = document.getElementById('s5'), sig = document.getElementById('significance');

    s1.onclick = () => {
      const origDs = tChart.data.datasets.find(ds => ds.label === 'Original');
      if (origDs) {
        origDs.borderColor = 'rgba(166, 124, 0, 0.2)';
        origDs.backgroundColor = 'rgba(166, 124, 0, 0.2)';
      }

      colors = colorArray(L);
      addDs('Points', original.map((y, i) => ({ x: i + 1, y })), { showLine: false, pointRadius: 5, pointBackgroundColor: colors });
      disable(s1); enable(s2);
    };
    s2.onclick = () => {
      detrended = original.map((v, i) => v - origTrend[i]);
      remDs('Points');
      addDs('Detrended', detrended.map((v, i) => ({ x: i + 1, y: v })), { showLine: false, pointRadius: 5, pointBackgroundColor: colors });
      disable(s2); enable(s3);
    };
    s3.onclick = () => {
      remDs('Detrended');
      doSim();
      manualCount++;
      if (manualCount >= 30) { s4Box.style.display = 'flex'; enable(s4); }
    };
    /* 1 000-run – every iter for first 10, then every 10 */
    s4.onclick = () => {
      disable(s3); disable(s4);
      const todo = 1000 - iters; let done = 0;
      const fastLoop = () => {
        const batchSize = done < 10 ? 1 : 10;
        for (let i = 0; i < batchSize && done < todo; i++, done++)doSim();
        if (done < todo) { requestAnimationFrame(fastLoop); } else { enable(s5); }
      };
      fastLoop();
    };
    s5.onclick = () => {
      const pct = (trends.filter(t => t <= tr).length / trends.length) * 100;
      const dir = tr >= 0 ? 'larger' : 'smaller';
      const pct2 = tr >= 0 ? pct.toFixed(1) : (100 - pct).toFixed(1);
      sig.innerHTML = `Your actual trend is ${dir} than ${pct2}% of the trends from the bootstrapped series.<br><br><b>But is this a valid test?</b> This 'Simple Bootstrap' method is only appropriate if the random noise in the series is truly independent (i.e., has no autocorrelation). By shuffling individual data points, we destroy the 'memory' of the original series.<br><br>If the original series had positive autocorrelation, this method will create a histogram of trends that is too narrow, making your real trend look far more significant than it actually is. This is a common and serious mistake in data analysis.<br><br>Compare this result to the one from a Block Bootstrap to see the difference!`;
      sig.style.display = 'block';
      updateBins();
      updateHist(tr, `Actual Trend (${pct2}th percentile)`);
      disable(s5);
    };

    /* ---------- simulation ---------- */
    function doSim() {
      if (!detrended.length) return;
      iters++; latestSlope = 0;
      const r = mul(Math.random() * 4294967296);
      const idx = [...Array(L)].map(() => Math.floor(r() * L));
      const sample = idx.map(i => detrended[i]);
      remDs('Detrended'); remDs('ResampledPoints'); remDs('ResampledLine'); remDs('ResampledTrend');

      /* resampled points + white dashed line */
      addDs('ResampledPoints', sample.map((v, i) => ({ x: i + 1, y: v })), { showLine: true, pointRadius: 5, pointBackgroundColor: idx.map(i => colors[i]), borderColor: '#fff', borderWidth: 1, borderDash: [2, 2] });

      /* yellow trend line */
      const { m, b } = ss.linearRegression(sample.map((v, i) => [i, v]));
      latestSlope = m;
      const trendLine = sample.map((_, i) => m * i + b);
      addDs('ResampledTrend', trendLine.map((v, i) => ({ x: i + 1, y: v })), { borderColor: '#ffeb3b', fill: false, pointRadius: 0, borderWidth: 3 });

      trends.push(m);
      iterDisplay.textContent = 'Iterations: ' + iters;
      updateBins();
      updateHist();
    }

    function updateBins() {
      if (trends.length) { const pad = Math.max((Math.max(...trends) - Math.min(...trends)) * 0.1, 1e-6); binMin = Math.min(...trends) - pad; binMax = Math.max(...trends) + pad; }
      else { binMin = -Math.max(Math.abs(tr), σ * 2); binMax = Math.max(Math.abs(tr), σ * 2); }
      binWidth = (binMax - binMin) / binCount;
    }
    function updateHist(actual = null, label = '') {
      const data = [...Array(binCount)].map((_, i) => {
        const left = binMin + i * binWidth;
        const right = left + binWidth;
        const c = trends.filter(v => v >= left && v < right).length;
        return { x: left + binWidth / 2, y: c };
      });
      hChart.data.datasets[0].data = data;

      const ann = {};
      if (latestSlope !== null) {
        ann.line = { type: 'line', xMin: latestSlope, xMax: latestSlope, borderColor: '#ffeb3b', borderWidth: 2, label: { content: 'Latest slope', display: true, position: 'top' } };
        ann.lab = { type: 'label', xValue: latestSlope, yValue: hChart.scales?.y?.max * 0.9 ?? 10, backgroundColor: 'rgba(255,255,255,.8)', borderColor: '#3e3a36', color: '#3e3a36', font: { size: 12 }, content: latestSlope.toFixed(4) };
      }
      if (actual !== null) {
        ann.actLine = { type: 'line', xMin: actual, xMax: actual, borderColor: '#ff6384', borderWidth: 2, label: { content: 'Actual', display: true, position: 'top' } };
      }
      hChart.options.plugins.annotation = { annotations: ann };
      hChart.update('none');
    }

    const helpModal = document.getElementById('helpModal');
    const helpTitle = document.getElementById('helpTitle');
    const helpBody = document.getElementById('helpBody');

    const helpContent = {
      's1-simple': {
        title: 'Independent Samples',
        body: 'This is the first step in the bootstrap process. We are considering each data point in the time series as an independent sample. This is a key assumption of the simple bootstrap method.'
      },
      's2-simple': {
        title: 'The Null Hypothesis',
        body: "The fundamental question we are asking is: 'Could the trend we see in our data have occurred by pure chance?' This is the null hypothesis (H₀). To test it, we need to create a world where H₀ is true (i.e., a world with no underlying trend). We do this by calculating the trend of our original series and then subtracting it out, leaving only the random 'noise' (the residuals). The rest of the bootstrap process will take place in this 'no-trend' world."
      },
      's3-simple': {
        title: 'Resampling with Replacement',
        body: "This is the heart of the bootstrap. We create a new, synthetic series by 'resampling' from our pool of noise points. We randomly pick one noise point, add it to our new series, put it back into the pool, and pick again. We repeat this until our synthetic series is the same length as the original. Because we sample with replacement, some original noise points will be picked multiple times, and some not at all. Crucially, their original time order is completely scrambled."
      }
    };

    function showHelp(topic) {
      helpTitle.textContent = helpContent[topic].title;
      helpBody.innerHTML = helpContent[topic].body;
      helpModal.style.display = 'block';
    }

    function closeHelp() {
      helpModal.style.display = 'none';
    }

    window.onclick = function (event) {
      if (event.target == helpModal) {
        closeHelp();
      }
    }

  </script>
</body>

</html>