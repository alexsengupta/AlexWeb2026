<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Monte Carlo Simulations (AR1 Model)</title>
  <style>
    :root {
      --bg: #3e3a36;
      --pane: #5a534d;
      --text: #d9cbb6;
      --accent: #a67c00;
      --inactive: #7a6f63;
      --trend: #000;
      --randTrend: #ffeb3b;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 20px;
    }

    h1 {
      margin: 0 0 10px 0;
      text-align: center;
    }

    #topChart {
      position: relative;
      width: 100%;
      height: 480px;
      background: var(--pane);
      border-radius: 8px;
      padding: 10px;
    }

    #topChart .innerLegend,
    #topChart .innerCount {
      position: absolute;
      font-size: 14px;
      color: #d9cbb6;
      background: rgba(0, 0, 0, .55);
      padding: 6px 8px;
      border-radius: 4px;
      pointer-events: none
    }

    #topChart .innerLegend {
      left: 50px;
      bottom: 50px;
      line-height: 20px;
      display: flex;
      flex-direction: column;
      gap: 2px
    }

    #topChart .innerCount {
      right: 50px;
      bottom: 50px
    }

    #bottomRow {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 20px;
    }

    #hist {
      flex: 2 1 420px;
      height: 280px;
      background: var(--pane);
      border-radius: 8px;
      padding: 10px;
      box-sizing: border-box;
    }

    #steps {
      flex: 1 1 250px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .stepBox {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
      color: var(--text);
    }

    .step {
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 5px;
      padding: 8px 12px;
      font-weight: bold;
      cursor: pointer;
      transition: opacity .3s;
    }

    .step:disabled {
      opacity: .4;
      cursor: default;
    }

    #significance {
      margin-top: 15px;
      display: none;
      background: var(--pane);
      padding: 12px;
      border-radius: 8px;
      line-height: 1.4;
    }

    .help-icon {
      cursor: pointer;
      font-weight: bold;
      color: var(--accent);
      margin-left: 5px;
    }

    .help-box {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--pane);
      border: 1px solid var(--accent);
      padding: 20px;
      border-radius: 8px;
      z-index: 1000;
      width: 80%;
      max-width: 500px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .help-box h2 {
      margin-top: 0;
      color: var(--accent);
    }

    .help-box .close-button {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: 20px;
      color: var(--text);
    }
  </style>
</head>

<body>
  <div style="position: absolute; top: 20px; left: 20px; display: flex; gap: 10px; z-index: 1000;">
    <a href="../../app_playground.html"
      style="text-decoration: none; background: rgba(255,255,255,0.1); color: #d9cbb6; padding: 8px 15px; border-radius: 99px; font-size: 14px; display: flex; align-items: center; gap: 8px; transition: background 0.2s; border: 1px solid rgba(255,255,255,0.2);">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round">
        <path d="M19 12H5M12 19l-7-7 7-7" />
      </svg>
      Playground
    </a>
    <a href="../../index.html"
      style="text-decoration: none; background: rgba(255,255,255,0.1); color: #d9cbb6; padding: 8px 15px; border-radius: 99px; font-size: 14px; display: flex; align-items: center; gap: 8px; transition: background 0.2s; border: 1px solid rgba(255,255,255,0.2);">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round">
        <path
          d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
      </svg>
      Home
    </a>
  </div>
  <h1>Significance Test: Parametric (AR1) Bootstrap</h1>

  <div id="topChart">
    <canvas id="timeCanvas"></canvas>
    <div class="innerLegend">
      <svg width="160" height="90">
        <line x1="0" y1="8" x2="20" y2="8" stroke="#a67c00" stroke-width="3" />
        <text x="24" y="12" fill="#d9cbb6">Original</text>

        <line x1="0" y1="26" x2="20" y2="26" stroke="#000" stroke-width="2" stroke-dasharray="4 2" />
        <text x="24" y="30" fill="#d9cbb6">Original trend</text>

        <line x1="0" y1="44" x2="20" y2="44" stroke="#fff" stroke-width="2" stroke-dasharray="2 2" />
        <text x="24" y="48" fill="#d9cbb6">Synthetic series</text>

        <line x1="0" y1="62" x2="20" y2="62" stroke="#ffeb3b" stroke-width="2" />
        <text x="24" y="66" fill="#d9cbb6">Synthetic trend</text>
      </svg>
    </div>
    <div class="innerCount" id="iterDisplay">Iterations: 0</div>
  </div>

  <div id="bottomRow">
    <div id="hist"><canvas id="histCanvas"></canvas></div>
    <div id="steps">
      <div class="stepBox">Step 1: Detrend original timeseries <span class="help-icon"
          onclick="showHelp('s1-ar')">?</span><button id="s1" class="step">Detrend & Model the Noise</button></div>
      <div class="stepBox">Step 2: Create Synthetic timeseries <span class="help-icon"
          onclick="showHelp('s2-ar')">?</span><button id="s2" class="step" disabled>Generate from Model</button></div>
      <div class="stepBox" id="s3Box">Step 3: <button id="s3" class="step" disabled>Repeat 1000×</button></div>
      <div class="stepBox">Step 4: <button id="s4" class="step" disabled>Compare actual</button></div>
    </div>
  </div>
  <div id="significance"></div>

  <div id="helpBox" class="help-box">
    <span class="close-button" onclick="hideHelp()">×</span>
    <h2 id="helpTitle"></h2>
    <p id="helpBody"></p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.7.0/dist/simple-statistics.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
  <script>
    /* ---------- URL params ---------- */
    const P = new URLSearchParams(location.search);
    const L = +P.get('length') || 100, σ = +P.get('stdDev') || 1, tr = +P.get('trend') || 0, ar = +P.get('autoCorr') || 0, seed = +P.get('randomSeed') || Math.random();
    const mul = s => { return () => (s = Math.imul(s ^ s >>> 15, s | 1), s += Math.imul(s ^ s >>> 7, s | 61), ((s ^ s >>> 14) >>> 0) / 4294967296) };
    const randn = r => { let u = 0, v = 0; while (!u) u = r(); while (!v) v = r(); return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v) };
    const rng = mul(Math.floor(seed * 4294967296));

    function gen(len, std, trend, ac, rng) { const y = [], tLine = []; let prev = 0; for (let i = 0; i < len; i++) { tLine.push(trend * i); prev = ac * prev + Math.sqrt(1 - ac * ac) * randn(rng) * std; y.push(trend * i + prev) } return { y, tLine } }
    const { y: original, tLine: origTrend } = gen(L, σ, tr, ar, rng);
    const labels = [...Array(L).keys()].map(i => i + 1);
    const yMax = Math.max(...original, ...origTrend.map(v => Math.abs(v))) * 1.1;

    /* ---------- top canvas ---------- */
    const tCtx = document.getElementById('timeCanvas').getContext('2d');
    const hCtx = document.getElementById('histCanvas').getContext('2d');
    let tChart, hChart, latestSlope = null;
    tChart = new Chart(tCtx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          { label: 'Original', data: original, borderColor: '#a67c00', backgroundColor: '#a67c00', fill: false, pointRadius: 0, borderWidth: 3, tension: .2 },
          { label: 'Original trend', data: origTrend, borderColor: '#000', borderDash: [5, 5], fill: false, pointRadius: 0, borderWidth: 2 }
        ]
      },
      options: { responsive: true, maintainAspectRatio: false, animation: false, scales: { x: { ticks: { color: '#d9cbb6' }, grid: { color: '#7a6f63' } }, y: { min: -yMax, max: yMax, ticks: { color: '#d9cbb6' }, grid: { color: '#7a6f63' } } }, plugins: { legend: { display: false } } }
    });

    /* histogram – 15 equal-width bins ---------- */
    const binCount = 15; let binWidth, binMin, binMax;
    function updateBins() {
      if (trends.length) { const pad = Math.max((Math.max(...trends) - Math.min(...trends)) * 0.1, 1e-6); binMin = Math.min(...trends) - pad; binMax = Math.max(...trends) + pad; }
      else { binMin = -Math.max(Math.abs(tr), σ * 2); binMax = Math.max(Math.abs(tr), σ * 2); }
      binWidth = (binMax - binMin) / binCount;
    }
    hChart = new Chart(hCtx, {
      type: 'bar',
      data: { datasets: [{ label: 'Frequency', data: [], backgroundColor: '#a67c00', barPercentage: 1, categoryPercentage: 1 }] },
      options: { responsive: true, maintainAspectRatio: false, animation: false, plugins: { legend: { display: false }, annotation: { annotations: {} } }, scales: { x: { type: 'linear', title: { display: true, text: 'Trend', color: '#d9cbb6' }, ticks: { color: '#d9cbb6' }, grid: { color: '#7a6f63' } }, y: { title: { display: true, text: 'Count', color: '#d9cbb6' }, ticks: { color: '#d9cbb6', precision: 0 }, grid: { color: '#7a6f63' } } } }
    });

    /* ---------- state ---------- */
    let detrended = [], trends = [], iters = 0, manualCount = 0;
    let detrendedStdDev, detrendedAutoCorr;
    const addDs = (l, d, opt = {}) => { if (!tChart.data.datasets.find(ds => ds.label === l)) { tChart.data.datasets.push({ label: l, data: d, ...opt }); tChart.update('none') } };
    const remDs = l => { const i = tChart.data.datasets.findIndex(ds => ds.label === l); if (i > -1) { tChart.data.datasets.splice(i, 1); tChart.update('none') } };
    const disable = b => { b.disabled = true; b.style.opacity = '0.4' };
    const enable = b => { b.disabled = false; b.style.opacity = '1' };
    const iterDisplay = document.getElementById('iterDisplay');

    /* ---------- buttons ---------- */
    const s1 = document.getElementById('s1'), s2 = document.getElementById('s2'), s3 = document.getElementById('s3'), s4 = document.getElementById('s4'), s3Box = document.getElementById('s3Box'), sig = document.getElementById('significance');

    s1.onclick = () => { // Detrend
      const origDs = tChart.data.datasets.find(ds => ds.label === 'Original');
      if (origDs) {
        origDs.borderColor = 'rgba(166, 124, 0, 0.2)';
        origDs.backgroundColor = 'rgba(166, 124, 0, 0.2)';
      }

      detrended = original.map((v, i) => v - origTrend[i]);
      detrendedStdDev = ss.standardDeviation(detrended);
      detrendedAutoCorr = ss.sampleCorrelation(detrended.slice(0, -1), detrended.slice(1));

      addDs('Detrended', detrended.map((v, i) => ({ x: i + 1, y: v })), { showLine: true, pointRadius: 2, borderColor: '#ccc', borderWidth: 1 });

      disable(s1);
      enable(s2);
    };

    s2.onclick = () => { // Create synthetic
      doSim();
      manualCount++;
      if (manualCount >= 30) {
        s3Box.style.display = 'flex';
        enable(s3);
      }
    };

    s3.onclick = () => { // Repeat 1000x
      disable(s2);
      disable(s3);
      const todo = 1000 - iters; let done = 0;
      const fastLoop = () => {
        const batchSize = done < 10 ? 1 : 10;
        for (let i = 0; i < batchSize && done < todo; i++, done++)doSim();
        if (done < todo) { requestAnimationFrame(fastLoop); } else { enable(s4); }
      };
      fastLoop();
    };

    s4.onclick = () => { // Compare
      const pct = (trends.filter(t => t <= tr).length / trends.length) * 100;
      const dir = tr >= 0 ? 'larger' : 'smaller';
      const pct2 = tr >= 0 ? pct.toFixed(1) : (100 - pct).toFixed(1);
      sig.innerHTML = `Actual trend is ${dir} than ${pct2}% of the randomised trends.<br><br>If the trend lies outside of 90/95 or 99 % of the randomised trends that would suggest the original trend is significant at the p<0.1, p<0.05 or p<0.01 level.<br><br>This test is a parametric bootstrap. Instead of resampling the actual noise from the data, we first fit a simple mathematical model (an AR(1) process) to it. Then, we use that model as a 'recipe' to generate thousands of brand new, purely synthetic noise series.<br>When is this appropriate? This method is powerful and efficient if the original time-series' noise can be well-described by an AR(1) process. If the real noise structure is more complex, this model-based approach might give misleading results. It trades the robustness of the block bootstrap for statistical power, but relies on a stronger assumption about the nature of the data.`;
      sig.style.display = 'block';
      updateBins();
      updateHist(tr, `Actual Trend (${pct2}th percentile)`);
      disable(s4);
    };

    /* ---------- simulation ---------- */
    function doSim() {
      if (!detrended.length) return;
      iters++;
      latestSlope = 0;
      const r = mul(Math.random() * 4294967296);

      const { y: sample } = gen(L, detrendedStdDev, 0, detrendedAutoCorr, r);

      remDs('Detrended');
      remDs('SyntheticSeries');
      remDs('SyntheticTrend');

      addDs('SyntheticSeries', sample.map((v, i) => ({ x: i + 1, y: v })), { showLine: true, borderColor: '#fff', borderWidth: 1, borderDash: [2, 2], pointRadius: 0 });

      const { m, b } = ss.linearRegression(sample.map((v, i) => [i, v]));
      latestSlope = m;
      const trendLine = sample.map((_, i) => m * i + b);
      addDs('SyntheticTrend', trendLine.map((v, i) => ({ x: i + 1, y: v })), { borderColor: '#ffeb3b', fill: false, pointRadius: 0, borderWidth: 3 });

      trends.push(m);
      iterDisplay.textContent = 'Iterations: ' + iters;
      updateBins();
      updateHist();
    }

    function updateBins() {
      if (trends.length) { const pad = Math.max((Math.max(...trends) - Math.min(...trends)) * 0.1, 1e-6); binMin = Math.min(...trends) - pad; binMax = Math.max(...trends) + pad; }
      else { binMin = -Math.max(Math.abs(tr), σ * 2); binMax = Math.max(Math.abs(tr), σ * 2); }
      binWidth = (binMax - binMin) / binCount;
    }
    function updateHist(actual = null, label = '') {
      const data = [...Array(binCount)].map((_, i) => {
        const left = binMin + i * binWidth;
        const right = left + binWidth;
        const c = trends.filter(v => v >= left && v < right).length;
        return { x: left + binWidth / 2, y: c };
      });
      hChart.data.datasets[0].data = data;

      const ann = {};
      if (latestSlope !== null) {
        ann.line = { type: 'line', xMin: latestSlope, xMax: latestSlope, borderColor: '#ffeb3b', borderWidth: 2, label: { content: 'Latest slope', display: true, position: 'top' } };
        ann.lab = { type: 'label', xValue: latestSlope, yValue: hChart.scales?.y?.max * 0.9 ?? 10, backgroundColor: 'rgba(255,255,255,.8)', borderColor: '#3e3a36', color: '#3e3a36', font: { size: 12 }, content: latestSlope.toFixed(4) };
      }
      if (actual !== null) {
        ann.actLine = { type: 'line', xMin: actual, xMax: actual, borderColor: '#ff6384', borderWidth: 2, label: { content: 'Actual', display: true, position: 'top' } };
      }
      hChart.options.plugins.annotation = { annotations: ann };
      hChart.update('none');
    }

    const helpContent = {
      's1-ar': {
        title: 'What is a Parametric Model?',
        body: `In this step, we not only detrend the series but also estimate the parameters of the noise. We assume the noise follows an AR(1) 'recipe': noise(t) = a * noise(t-1) + random_shock. We calculate the best-fit values for the autocorrelation a and the standard deviation of the random_shock. These two parameters now define our model of the noise.`
      },
      's2-ar': {
        title: 'Simulating vs. Resampling',
        body: `This is the key difference from other bootstraps. We are NOT re-using the original noise points. We are using a random number generator and our estimated parameters (a and std dev) to create a completely new synthetic series from scratch. This is 'parametric' because the simulation is guided entirely by the parameters we estimated, not the original data points themselves.`
      }
    };

    function showHelp(id) {
      const helpBox = document.getElementById('helpBox');
      const helpTitle = document.getElementById('helpTitle');
      const helpBody = document.getElementById('helpBody');

      helpTitle.textContent = helpContent[id].title;
      helpBody.textContent = helpContent[id].body;
      helpBox.style.display = 'block';
    }

    function hideHelp() {
      document.getElementById('helpBox').style.display = 'none';
    }
  </script>
</body>

</html>